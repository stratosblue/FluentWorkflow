// <Auto-Generated/>
using System.ComponentModel;
using FluentWorkflow;
using FluentWorkflow.Extensions;
using FluentWorkflow.Interface;
using TemplateNamespace.Template;
using TemplateNamespace.Template.Message;

namespace TemplateNamespace
{
    partial class TemplateWorkflow
    {
        /// <summary>
        /// <see cref="TemplateWorkflow"/> 状态机基类
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public abstract partial class StateMachineBase
            : WorkflowStateMachine<ITemplateWorkflow>
            , ITemplateWorkflow
        {
            private readonly IWorkflowMessageDispatcher _messageDispatcher;

            /// <inheritdoc cref="TemplateWorkflowContext"/>
            protected readonly TemplateWorkflowContext TypedContext;

            /// <summary>
            /// 工作流程 <see cref="TemplateWorkflow"/> 实例
            /// </summary>
            protected readonly TemplateWorkflow Workflow;

            /// <inheritdoc cref="StateMachineBase"/>
            public StateMachineBase(TemplateWorkflow workflow, IWorkflowMessageDispatcher messageDispatcher, IServiceProvider serviceProvider)
                : base(workflow.Context, messageDispatcher, serviceProvider)
            {
                Workflow = workflow ?? throw new ArgumentNullException(nameof(workflow));
                TypedContext = workflow.Context;
                _messageDispatcher = messageDispatcher ?? throw new ArgumentNullException(nameof(messageDispatcher));
            }

            /// <inheritdoc/>
            public override async Task MoveNextAsync(CancellationToken cancellationToken)
            {
                var currentStage = Context.Stage;
                if (string.IsNullOrWhiteSpace(currentStage))
                {
                    currentStage = TemplateStages.Stage1CAUK;
                    Context.SetCurrentStage(currentStage);
                    if (!await Workflow.OnStartingAsync(TypedContext, cancellationToken))
                    {
                        return;
                    }
                }

                using var singleCaller = new ScopePublishStageMessageSingleCaller(MessageDispatcher);

                switch (currentStage)
                {
                    case TemplateStages.Stage1CAUK:
                        {
                            var stageMessage = new StageStage1CAUKMessage(WorkflowMessageIdProvider.Generate(), TypedContext);
                            stageMessage.Context.State.SetStageState(WorkflowStageState.Created);
                            await Workflow.OnStage1CAUKAsync(stageMessage, singleCaller.PublishStageMessageAsync, cancellationToken);
                            return;
                        }
                    case TemplateStages.Stage2BPTG:
                        {
                            var stageMessage = new StageStage2BPTGMessage(WorkflowMessageIdProvider.Generate(), TypedContext);
                            stageMessage.Context.State.SetStageState(WorkflowStageState.Created);
                            await Workflow.OnStage2BPTGAsync(stageMessage, singleCaller.PublishStageMessageAsync, cancellationToken);
                            return;
                        }
                    case TemplateStages.Stage3AWBN:
                        {
                            var stageMessage = new StageStage3AWBNMessage(WorkflowMessageIdProvider.Generate(), TypedContext);
                            stageMessage.Context.State.SetStageState(WorkflowStageState.Created);
                            await Workflow.OnStage3AWBNAsync(stageMessage, singleCaller.PublishStageMessageAsync, cancellationToken);
                            return;
                        }
                    case TemplateStages.Failure:
                        {
                            var failureInformation = Context.GetFailureInformation();
                            var finishedMessage = new TemplateFinishedMessage(WorkflowMessageIdProvider.Generate(), TypedContext, false, failureInformation?.Message ?? "Unknown error");
                            await _messageDispatcher.PublishAsync(finishedMessage, cancellationToken);
                            return;
                        }
                    case TemplateStages.Completion:
                        {
                            TypedContext.State.SetStageState(WorkflowStageState.Created);
                            await Workflow.OnCompletionAsync(TypedContext, cancellationToken);

                            if (Context.Flag.HasFlag(WorkflowFlag.IsBeenAwaited)
                                || !Context.Flag.HasFlag(WorkflowFlag.NotNotifyOnFinish))
                            {
                                var finishedMessage = new TemplateFinishedMessage(WorkflowMessageIdProvider.Generate(), TypedContext, true, "SUCCESS");
                                await _messageDispatcher.PublishAsync(finishedMessage, cancellationToken);
                            }
                            return;
                        }
                }
                throw new WorkflowInvalidOperationException($"未知的阶段：{currentStage}");
            }

            /// <inheritdoc/>
            public override Task<bool> IsCompletedAsync(CancellationToken cancellationToken)
            {
                var currentStage = Context.Stage;
                var result = string.Equals(TemplateStages.Completion, currentStage);

                return Task.FromResult(result);
            }

            /// <summary>
            /// 使用完成消息设置阶段完成
            /// </summary>
            /// <param name="stageCompletedMessage"></param>
            /// <param name="cancellationToken"></param>
            /// <returns>是否执行后续代码</returns>
            /// <exception cref="WorkflowInvalidOperationException"></exception>
            internal virtual async Task<bool> SetStageCompletedAsync(ITemplateStageCompletedMessage stageCompletedMessage, CancellationToken cancellationToken)
            {
                //设置上下文阶段状态，以使 OnStageCompletedAsync 中获取到的上下文当前阶段状态为已结束
                //如果在 OnStageCompletedAsync 中挂起上下文，在恢复流程时使用此值确定应当再次调用 SetStageCompletedAsync 而不是 MoveNextAsync
                stageCompletedMessage.Context.State.SetStageState(WorkflowStageState.Finished);

                using var singleCaller = new ScopeOnStageCompletedSingleCaller(this);

                var stageCompletedTask = stageCompletedMessage switch
                {
                    StageStage1CAUKCompletedMessage stage1CA5CStageCompletedMessage => Workflow.OnStage1CAUKCompletedAsync(stage1CA5CStageCompletedMessage, singleCaller.OnStageCompletedAsync, cancellationToken),
                    StageStage2BPTGCompletedMessage stage2B74EStageCompletedMessage => Workflow.OnStage2BPTGCompletedAsync(stage2B74EStageCompletedMessage, singleCaller.OnStageCompletedAsync, cancellationToken),
                    StageStage3AWBNCompletedMessage stage3A2B4StageCompletedMessage => Workflow.OnStage3AWBNCompletedAsync(stage3A2B4StageCompletedMessage, singleCaller.OnStageCompletedAsync, cancellationToken),
                    _ => throw new WorkflowInvalidOperationException($"未知的阶段完成消息：{stageCompletedMessage}"),
                };

                await stageCompletedTask;

                if (singleCaller.HasInvoked)
                {
                    SetCurrentStageToNext();
                    return true;
                }
                return false;

                void SetCurrentStageToNext()
                {
                    var nextStage = stageCompletedMessage.Stage switch
                    {
                        TemplateStages.Stage1CAUK => TemplateStages.Stage2BPTG,
                        TemplateStages.Stage2BPTG => TemplateStages.Stage3AWBN,
                        TemplateStages.Stage3AWBN => TemplateStages.Completion,
                        _ => throw new WorkflowInvalidOperationException($"未知的阶段完成消息：{stageCompletedMessage}"),
                    };

                    Context.SetCurrentStage(nextStage);
                }
            }

            /// <summary>
            /// 使用失败消息设置流程失败
            /// </summary>
            /// <param name="failureMessage"></param>
            /// <param name="cancellationToken"></param>
            /// <returns>是否执行后续代码</returns>
            /// <exception cref="WorkflowInvalidOperationException"></exception>
            internal virtual async Task<bool> SetFailedAsync(ITemplateFailureMessage failureMessage, CancellationToken cancellationToken)
            {
                if (failureMessage is not TemplateFailureMessage typedFailureMessage)
                {
                    throw new WorkflowInvalidOperationException($"未知的失败消息：{failureMessage}");
                }

                using var singleCaller = new ScopeOnFailedSingleCaller(this);

                await Workflow.OnFailedAsync(typedFailureMessage, singleCaller.OnFailedAsync, cancellationToken);

                return singleCaller.HasInvoked;
            }

            /// <inheritdoc/>
            protected override async Task OnFailedAsync<TFailureMessage>(TFailureMessage failureMessage, CancellationToken cancellationToken)
            {
                await base.OnFailedAsync(failureMessage, cancellationToken);

                Context.SetCurrentStage(TemplateStages.Failure);
            }
        }
    }
}

namespace TemplateNamespace.Template.Internal
{
    /// <summary>
    /// <see cref="TemplateWorkflow"/> 的状态机
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public sealed partial class TemplateWorkflowStateMachine : TemplateWorkflow.StateMachineBase
    {
        /// <inheritdoc/>
        public TemplateWorkflowStateMachine(TemplateWorkflow workflow, IWorkflowMessageDispatcher messageDispatcher, IServiceProvider serviceProvider) : base(workflow, messageDispatcher, serviceProvider)
        {
        }
    }
}
