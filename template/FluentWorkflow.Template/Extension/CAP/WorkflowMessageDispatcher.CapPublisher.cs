// <Auto-Generated/>
using System.ComponentModel;
using DotNetCore.CAP;
using FluentWorkflow.Diagnostics;
using FluentWorkflow.Interface;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;

namespace FluentWorkflow.GenericExtension.TemplateNamespace;

/// <summary>
/// 基于 cap 的 <inheritdoc cref="IWorkflowMessageDispatcher"/> 默认实现
/// </summary>
internal partial class CapPublisherWorkflowMessageDispatcher : WorkflowMessageDispatcher
{
    private readonly ICapPublisher _capPublisher;

    /// <inheritdoc cref="CapPublisherWorkflowMessageDispatcher"/>
    public CapPublisherWorkflowMessageDispatcher(ICapPublisher capPublisher, IWorkflowDiagnosticSource diagnosticSource, ILoggerFactory loggerFactory)
        : base(diagnosticSource, loggerFactory?.CreateLogger("FluentWorkflow.CapPublisherWorkflowMessageDispatcher"))
    {
        _capPublisher = capPublisher ?? throw new ArgumentNullException(nameof(capPublisher));
    }

    /// <inheritdoc/>
    public override async Task PublishAsync<TMessage>(TMessage message, CancellationToken cancellationToken)
    {
        await base.PublishAsync(message, cancellationToken);
        await _capPublisher.PublishAsync(TMessage.EventName, message, cancellationToken: cancellationToken);
    }
}

/// <summary>
/// 
/// </summary>
[EditorBrowsable(EditorBrowsableState.Never)]
public static partial class CapPublisherWorkflowMessageDispatcherDIExtensions
{
    /// <summary>
    /// 使用基于 cap 的 <inheritdoc cref="IWorkflowMessageDispatcher"/>
    /// </summary>
    /// <param name="builder"></param>
    /// <returns></returns>
    public static IFluentWorkflowBuilder UseCapPublisherWorkflowMessageDispatcher(this IFluentWorkflowBuilder builder)
    {
        builder.Services.Replace(ServiceDescriptor.Scoped<IWorkflowMessageDispatcher, CapPublisherWorkflowMessageDispatcher>());
        return builder;
    }
}
