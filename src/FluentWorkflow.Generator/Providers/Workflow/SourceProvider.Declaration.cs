using System.Collections.Immutable;
using System.Text;
using FluentWorkflow.Generator.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace FluentWorkflow.Generator.Providers.Workflow;

internal class DeclarationSourceProvider : SourceProvider
{
    #region Private 字段

    private readonly WorkflowDeclaration _declaration;

    private readonly string _usings;

    #endregion Private 字段

    #region Public 构造函数

    public DeclarationSourceProvider(WorkflowDeclaration declaration)
    {
        _declaration = declaration;

        var usingBuilder = new StringBuilder(512);
        foreach (var usingItem in declaration.DeclarationSyntax.SyntaxTree.GetCompilationUnitRoot().Usings)
        {
            usingBuilder.AppendLine(usingItem.ToString());
        }

        usingBuilder.AppendLine($"using System.ComponentModel;");
        usingBuilder.AppendLine($"using FluentWorkflow;");

        _usings = usingBuilder.ToString();
    }

    #endregion Public 构造函数

    #region Public 方法

    public override IEnumerable<GeneratedSource?>? Generate()
    {
        var builder = new StringBuilder(2048);

        builder.AppendLine($@"// <Auto-Generated/>

{_usings}
namespace {_declaration.NameSpace};

");
        builder.AppendLine($"[WorkflowDefine({(int)GeneratorVersion.Version2}, \"{_declaration.WorkflowName}\", {string.Join(", ", _declaration.Stages.Select(m => $"\"{m}\""))}]");

        foreach (var property in _declaration.ContextProperties)
        {
            builder.AppendLine($"[WorkflowContextTypedProperty<{property.Type.ToFullCodeString()}>(\"{property.Name}\", \"{property.Comment}\")]");
        }

        builder.AppendLine($@"
sealed partial class {_declaration.DeclarationName}
{{
}}
");
        yield return new($"{_declaration.DeclarationName}.Declaration.g.cs", builder.ToString());
    }

    #endregion Public 方法
}
