using System.Text;
using FluentWorkflow.Generator.Model;
using Microsoft.CodeAnalysis.CSharp;

namespace FluentWorkflow.Generator.Providers.Workflow;

internal class DeclarationBaseSourceProvider : SourceProvider
{
    #region Private 字段

    private readonly WorkflowDeclaration _descriptor;

    private readonly string _usings;

    #endregion Private 字段

    #region Public 构造函数

    public DeclarationBaseSourceProvider(WorkflowDeclaration descriptor)
    {
        _descriptor = descriptor;

        var usingBuilder = new StringBuilder(512);
        foreach (var usingItem in descriptor.DeclarationSyntax.SyntaxTree.GetCompilationUnitRoot().Usings)
        {
            usingBuilder.AppendLine(usingItem.ToString());
        }

        usingBuilder.AppendLine($"using System.ComponentModel;");
        usingBuilder.AppendLine($"using FluentWorkflow;");

        _usings = usingBuilder.ToString();
    }

    #endregion Public 构造函数

    #region Public 方法

    public override IEnumerable<GeneratedSource?>? Generate()
    {
        var builder = new StringBuilder(2048);

        builder.AppendLine($@"// <Auto-Generated/>

{_usings}
namespace {_descriptor.NameSpace};

/// <summary>
/// <see cref=""{_descriptor.DeclarationName}""/> 的辅助定义基类
/// </summary>
[EditorBrowsable(EditorBrowsableState.Never)]
public abstract class {_descriptor.DeclarationName}Base : IWorkflowDeclaration
{{
    #region Internal 方法

    /// <summary>
    /// 声明工作流程上下文
    /// </summary>
    /// <param name=""declarator""></param>
    internal abstract void DeclareContext(IWorkflowContextDeclarator declarator);

    /// <summary>
    /// 声明工作流程
    /// </summary>
    /// <param name=""declarator""></param>
    internal abstract void DeclareWorkflow(IWorkflowDeclarator declarator);

    #endregion Internal 方法
}}

partial class {_descriptor.DeclarationName} : {_descriptor.DeclarationName}Base 
{{
}}
");
        yield return new($"{_descriptor.DeclarationName}.DeclarationBase.g.cs", builder.ToString());
    }

    #endregion Public 方法
}
